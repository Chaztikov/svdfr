# jemdoc: menu{MENU}{algo.html},addpackage{amsmath},addpackage{amssymb}
# jemdoc: addcss{jemdoc.css}
# jemdoc: addcss{bibover.css}
#include{masterFile_2.jeminc}
#include{mj-complete-bib_3.jeminc}
= Algorithm and Implementation

== Algorithm
Computations with the previous version of [/javascript:cite('liejovJCP13') +SVDFR+]
were based on computing the eigenvalues of the cascaded system.
The current version of [index.html +SVDFR+] is based on a feedback interconnected
system (see the [/javascript:cite('harkumjovJCP21') accompanying paper] and Theorem 1 in this [/javascript:cite('Boyd1989') article]). 

For a system of the form,
\(
\begin{array}{ccc}
\mathcal A \,\phi (y) \!\!&=&\!\! \mathcal B \,d(y),\\
\xi (y) \!\!&=&\!\! \mathcal C\, \phi(y),
\end{array}
\)
whose adjoint system is given by,
\(
\begin{array}{ccc}
\mathcal A^{\,\dagger} \,\psi (y) \!\!&=&\!\! \mathcal C^{\,\dagger} \,g(y),\\
\zeta (y) \!\!&=&\!\! \mathcal B^{\,\dagger}\, \psi(y),
\end{array}
\)
the following eigenvalue problem can be used to compute the singular values:
\(
\left[
\begin{array}{cc}
  0 &\mathcal{B}\mathcal{B}^{\,\dagger} \\
   \mathcal{C}^{\,\dagger}\mathcal{C}&0
\end{array} \right] \left[ \begin{array}{c}
  \phi(y)\\
  \psi(y)
\end{array} \right]   \;=\; \lambda \,\left[\begin{array}{cc}
  \mathcal{A} & 0\\
  0 & \mathcal{A}^{\,\dagger}
\end{array}\right]\left[ \begin{array}{c}
  \phi(y)\\
  \psi(y)
\end{array} \right].
\)
The singular values can be recovered as $\lambda  = \pm \sigma$. The function
+SVDFR+ with the 'inverse' flag works with the inverse problem to solve for $1/\lambda$, i.e.,
\(
  \left[\begin{array}{cc}
  \mathcal{A} & 0\\
  0 & \mathcal{A}^{\,\dagger}
\end{array}\right]\left[ \begin{array}{c}
  \phi(y)\\
  \psi(y)
\end{array} \right]  \;=\;\frac{1}{\lambda} \left[  \begin{array}{cc}
  0 &\mathcal{B}\mathcal{B}^{\,\dagger} \\
   \mathcal{C}^{\,\dagger}\mathcal{C}&0
\end{array} \right] \left[ \begin{array}{c}
  \phi(y)\\
  \psi(y)
\end{array} \right] .
\)

~~~
{}{raw}
<figure>
  <img src="pics/cascade.svg" alt="3dflow" style="width:60%">
  <figcaption>Fig.\(1\) Block diagram of a cascade connection of the operators \(\mathcal{T}^{\dagger}(\omega)\) and \(\mathcal T(\omega)\). The composite operator, \(\mathcal{T}^{\dagger}(\omega) \mathcal T(\omega)\), can be used to compute the singular values of the frequency response operator \(\mathcal T(\omega)\).</a></figcaption>
</figure>
~~~


~~~
{}{raw}
<figure>
  <img src="pics/feedback.svg" alt="3dflow" style="width:60%">
  <figcaption>Fig.\(2\) Through a sequence of transformations, the cascade connection of the operators \(\mathcal{T}^{\dagger}(\omega)\) and \(\mathcal T(\omega)\) shown in~\fref{fig:cascade} is cast as a feedback interconnection of \((1/\sigma) \, \mathcal{T}^{\dagger}(\omega)\) and \((1/\sigma) \, \mathcal T(\omega)\)~<a href="javascript:cite('Boyd1989')">(Theorem 1 from Boyd et al.).</a>.</a></figcaption>
</figure>
~~~
For a system,
\(
  \begin{align}
    \left[\mathcal A(\omega)\,\mbox{$\boldsymbol \phi$}(\cdot)\right] (y) \;&=\; \left[\mathcal B(\omega)\,\boldsymbol d(\cdot)\right](y),\\
    \mbox{$\boldsymbol\xi$} (y)\;&=\; \left[\mathcal C(\omega)\,\mbox{$\boldsymbol\phi$}(\cdot)\right](y),\\
    [\mathcal{L}_a \, \mbox{$\boldsymbol\phi$}(\cdot)](a)  \;&=\; [\mathcal{L}_b \, \mbox{$\boldsymbol\phi$}(\cdot)](b) \;=\;  0,\label{eq:mot1c}
  \end{align}  
\)

The frequency response operator $\mathcal{T}(\omega) = \mathcal{C}(\omega) \mathcal A ^{-1}(\omega) \mathcal{B}(\omega)$
in is described by
\(
  \begin{equation}\label{eq:regularOp}
	 \mbox{$\boldsymbol\xi$}(y)
	 \; = \;
	 [ \mathcal{T} \boldsymbol{d} (\cdot) ] (y)
	 ~~ \Leftrightarrow ~~
	\left\{
	\begin{aligned}
      {
      [ \mathcal{A} \, \mbox{$\boldsymbol\phi$} ( \cdot ) ] (y)
      }
      \;&=\;
      [ \mathcal{B} \,\boldsymbol{d} (\cdot) ] (y),
      &
      \\
  \mbox{$\boldsymbol\xi$}(y)  \;&=\;  [ \mathcal{C}\,\mbox{$\boldsymbol\phi$} (\cdot) ] (y) ,&\\
[\mathcal{L}_a \, \mbox{$\boldsymbol\phi$}(\cdot)](a)  \;&=\;  [\mathcal{L}_b \, \mbox{$\boldsymbol\phi$}(\cdot)](b)  \; = \;  0, &
\end{aligned}
	\right.
\end{equation}
\)
and the adjoint operator $\mathcal{T}^{\dagger}(\omega)=\mathcal{B}^\dagger(\omega)\mathcal{A}^{-\dagger}(\omega)\mathcal{C}^\dagger(\omega)$ is determined by
\(
	\begin{equation}
	\label{eq:adjointOp}
	\mbox{$\boldsymbol\zeta$}(y)
	\; = \;
	[ \mathcal{T}^{\dagger} \boldsymbol{g} ( \cdot ) ] (y)
	~~ \Leftrightarrow ~~
	\left\{
	\begin{aligned}
     {[ \mathcal{A}^{\dagger} \mbox{$\boldsymbol\psi$} ( \cdot ) ] (y)} \;&=\;  [ \mathcal{C}^\dagger \boldsymbol{g} ( \cdot ) ] (y),&\\
  \mbox{$\boldsymbol\zeta$}(y)  \;&=\;   [ \mathcal{B}^{\dagger} \mbox{$\boldsymbol\psi$} ( \cdot ) ] (y),&\\
[\mathcal{L}_a^\dagger \mbox{$\boldsymbol\psi$} (\cdot)](a)  \;&=\;  [\mathcal{L}_b^\dagger \mbox{$\boldsymbol\psi$}(\cdot)](b)  \; = \;  0, &
\end{aligned} \right.
\end{equation}
\)

This system can be equivalently expressed as the generalized eigenvalue problem,
\(
\begin{align}\label{eq:matrixEvalProb}
\left[
\begin{array}{cc}
  0 &\mathcal{B}\mathcal{B}^{\dagger} \\
   \mathcal{C}^{\dagger}\mathcal{C}&0
\end{array} \right] \left[ \begin{array}{c}
  \tilde{\boldsymbol \phi} \\
  \tilde{\boldsymbol \psi}
\end{array} \right]
\;=\;
\gamma \left[\begin{array}{cc}
  \mathcal{A} & 0\\
  0 & \mathcal{A}^{\dagger}
\end{array}\right]
\left[ \begin{array}{c}
  \tilde{\boldsymbol \phi} \\
  \tilde{\boldsymbol \psi}
\end{array} \right],
\end{align}
\)
where we suppress the dependence on the spatial variable $y$ for brevity. Eigenvalues resulting from this approach determine the singular values in pairs of opposite signs, i.e., $\gamma = \pm \sigma$. 
where we suppress the dependence on $\omega$ for notational convenience.
== Implementation details

As discussed in the section on [algo.html algorithm], the eigenvalue problem,
\(
  \begin{equation}\label{eq:1}
\left[
\begin{array}{cc}
  0 &\mathcal{B}\mathcal{B}^{\,\dagger} \\
   \mathcal{C}^{\,\dagger}\mathcal{C}&0
\end{array} \right] \left[ \begin{array}{c}
  \phi(y)\\
  \psi(y)
\end{array} \right]   \;=\; \lambda \,\left[\begin{array}{cc}
  \mathcal{A} & 0\\
  0 & \mathcal{A}^{\,\dagger}
\end{array}\right]\left[ \begin{array}{c}
  \phi(y)\\
  \psi(y)
\end{array} \right], 
\end{equation}
\)
\n
 needs to be solved. This requires several steps:
  . Compute the adjoint operators.
  . Compute the adjoint boundary conditions.
  . Generate the new operator based on Eq.~$\eqref{eq:1}$
  . Compute the eigenvalues

Each step is addressed in the following manner:

=== Adjoint operators

Chebfun has a function for the formal adjoint titled of a linear operator
titled +adjointFormal()+ that can be found in +chebfun/adjoints.m+. Although
+adjointFormal()+ was intended for square linear operators, we found that their
implementation was also suitable for non-square operators. Hence we use their
code as is without any change to compute the formal adjoint.

=== Adjoint boundary conditions

The adjoint boundary conditions are determined analytically using a procedure
similar to what is used by [/javascript:cite('liejovJCP13') Lieu and Jovanovic].
This algorithm is based on the method in [/javascript:cite('renardy2006introduction') Renardy's book].
The method there-in can be extended to periodic boundary conditions as well
(we are working on it, although we currently support only boundary conditions
at the endpoints).

Note that Chebfun has a built-in tool for adjoint boundary conditions.
We do not use it as their current implementation needs that the highest
order of all variables for a system of differential equations be the same. This means that
that it cannot be used for systems like the [3dchannelflow.html 3D channel flow example].
The implementation in [/javascript:cite('liejovJCP13') Lieu and Jovanovic] is more
robust.

Email [harih020@umn.edu Gokul] if you need more details/information on this.

=== The interconnected system
This section deals with making a system as given in (1) using Chebfun.
We firstly convert chebops, $A$, $B$ and $C$ into linops using the +linearize()+
function in Chebfun. We then construct the adjoint operators using +adjointFormal()+, and the
composite operators $\mathcal B\mathcal B^{\,\dagger}$ and $\mathcal C^{\dagger}\mathcal C$.

~~~
{}{matlab}
Aop = linearize(A,0*A.init);
Bop = linearize(B,0*B.init);
Cop = linearize(C,0*C.init);

pref = chebfunpref();
Astarop = adjointFormal(Aop,pref);
Bstarop = adjointFormal(Bop,pref);
Cstarop = adjointFormal(Cop,pref);

BBstar = linop(Bop*Bstarop);
CstarC = linop(Cstarop*Cop);
~~~

We then make the operator representing equation (1) as,

~~~
{}{matlab}
M = [Aop, Zlinop;
    Zlinop, Astarop];
L = [Zlinop,BBstar;CstarC,Zlinop];
~~~
As +L+ and +M+ are manually constructed linops, we need to fill the field linop.constraint
before we can call linop/eigs.m. For this we construct a dummy chebop
whose entries are simply the highest derivatives of the +Aop+ and +Astarop+, append boundary conditions
, and linearize it to get a replica of the constraint. This follows from the
fact that the equations for discretized boundary conditions only depend on the
highest derivatives
on the differential equation and not on the non-constant coefficients in
spectral discretizations used in Chebfun.
~~~
{}{matlab}
dummy = chebop(Aop.domain);
% -- define the dummy chebop -- %

% Fix new boundary conditions on dummy
dummy.lbc = lbcnew;
dummy.rbc = rbcnew;
linCheck = true;
dummy = linearize(dummy, dummy.init, [], linCheck);

% Attach dummy's constraints to L
L.constraint = dummy.constraint;

~~~

=== Computing eigenvalues

The eigenvalues are computed using linop/eigs.m,
~~~
{}{matlab}
[V,lam] = eigs(L,M);
~~~
For the sake of transparency, although the singular value returned has to be
real,
we do not set the imaginary part to zero. If the solution for +lam+ has a
non-zero imaginary part, it is possible that the solution is not sufficiently
resolved, or that there is something wrong with our implementation. If you feel it
is the latter, report it [https://github.com/gokulhari/svdfr3/issues here].